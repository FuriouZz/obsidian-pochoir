export function generate(node: any, options: any): any;
export const NEEDS_PARENTHESES: 17;
export namespace EXPRESSIONS_PRECEDENCE {
    export let ArrayExpression: number;
    export let TaggedTemplateExpression: number;
    export let ThisExpression: number;
    export let Identifier: number;
    export let PrivateIdentifier: number;
    export let Literal: number;
    export let TemplateLiteral: number;
    export let Super: number;
    export let SequenceExpression: number;
    export let MemberExpression: number;
    export let ChainExpression: number;
    export let CallExpression: number;
    export let NewExpression: number;
    export { NEEDS_PARENTHESES as ArrowFunctionExpression };
    export { NEEDS_PARENTHESES as ClassExpression };
    export { NEEDS_PARENTHESES as FunctionExpression };
    export { NEEDS_PARENTHESES as ObjectExpression };
    export let UpdateExpression: number;
    export let UnaryExpression: number;
    export let AwaitExpression: number;
    export let BinaryExpression: number;
    export let LogicalExpression: number;
    export let ConditionalExpression: number;
    export let AssignmentExpression: number;
    export let YieldExpression: number;
    export let RestElement: number;
}
export namespace GENERATOR {
    export function Program(node: any, state: any): void;
    export function BlockStatement(node: any, state: any): void;
    export { BlockStatement as ClassBody };
    export function StaticBlock(node: any, state: any): void;
    export function EmptyStatement(node: any, state: any): void;
    export function ExpressionStatement(node: any, state: any): void;
    export function IfStatement(node: any, state: any): void;
    export function LabeledStatement(node: any, state: any): void;
    export function BreakStatement(node: any, state: any): void;
    export function ContinueStatement(node: any, state: any): void;
    export function WithStatement(node: any, state: any): void;
    export function SwitchStatement(node: any, state: any): void;
    export function ReturnStatement(node: any, state: any): void;
    export function ThrowStatement(node: any, state: any): void;
    export function TryStatement(node: any, state: any): void;
    export function WhileStatement(node: any, state: any): void;
    export function DoWhileStatement(node: any, state: any): void;
    export function ForStatement(node: any, state: any): void;
    export function ForInStatement(node: any, state: any): void;
    export { ForInStatement as ForOfStatement };
    export function DebuggerStatement(node: any, state: any): void;
    export function FunctionDeclaration(node: any, state: any): void;
    export { FunctionDeclaration as FunctionExpression };
    export function VariableDeclaration(node: any, state: any): void;
    export function VariableDeclarator(node: any, state: any): void;
    export function ClassDeclaration(node: any, state: any): void;
    export function ImportDeclaration(node: any, state: any): void;
    export function ImportExpression(node: any, state: any): void;
    export function ExportDefaultDeclaration(node: any, state: any): void;
    export function ExportNamedDeclaration(node: any, state: any): void;
    export function ExportAllDeclaration(node: any, state: any): void;
    export function MethodDefinition(node: any, state: any): void;
    export function ClassExpression(node: any, state: any): void;
    export function ArrowFunctionExpression(node: any, state: any): void;
    export function ThisExpression(node: any, state: any): void;
    export function Super(node: any, state: any): void;
    export function RestElement_1(node: any, state: any): void;
    export { RestElement_1 as RestElement };
    export { RestElement as SpreadElement };
    export function YieldExpression(node: any, state: any): void;
    export function AwaitExpression(node: any, state: any): void;
    export function TemplateLiteral(node: any, state: any): void;
    export function TemplateElement(node: any, state: any): void;
    export function TaggedTemplateExpression(node: any, state: any): void;
    export function ArrayExpression_1(node: any, state: any): void;
    export { ArrayExpression_1 as ArrayExpression };
    export { ArrayExpression as ArrayPattern };
    export function ObjectExpression(node: any, state: any): void;
    export function Property(node: any, state: any): void;
    export function PropertyDefinition(node: any, state: any): void;
    export function ObjectPattern(node: any, state: any): void;
    export function SequenceExpression(node: any, state: any): void;
    export function UnaryExpression(node: any, state: any): void;
    export function UpdateExpression(node: any, state: any): void;
    export function AssignmentExpression(node: any, state: any): void;
    export function AssignmentPattern(node: any, state: any): void;
    export function BinaryExpression_1(node: any, state: any): void;
    export { BinaryExpression_1 as BinaryExpression };
    export { BinaryExpression as LogicalExpression };
    export function ConditionalExpression(node: any, state: any): void;
    export function NewExpression(node: any, state: any): void;
    export function CallExpression(node: any, state: any): void;
    export function ChainExpression(node: any, state: any): void;
    export function MemberExpression(node: any, state: any): void;
    export function MetaProperty(node: any, state: any): void;
    export function Identifier(node: any, state: any): void;
    export function PrivateIdentifier(node: any, state: any): void;
    export function Literal(node: any, state: any): void;
    export function RegExpLiteral(node: any, state: any): void;
}
export namespace baseGenerator { }
declare let BlockStatement_1: any;
declare let ForInStatement_1: any;
declare let FunctionDeclaration_1: any;
declare let RestElement_2: any;
declare let ArrayExpression_2: any;
declare let BinaryExpression_2: any;
export {};
//# sourceMappingURL=astring.d.ts.map